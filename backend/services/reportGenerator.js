import PDFDocument from 'pdfkit';

export async function generatePDFReport(audit) {
  return new Promise((resolve, reject) => {
    try {
      const doc = new PDFDocument({ margin: 50 });
      const chunks = [];

      doc.on('data', chunk => chunks.push(chunk));
      doc.on('end', () => resolve(Buffer.concat(chunks)));
      doc.on('error', reject);

      // Header
      doc.fontSize(24).fillColor('#1a1a1a').text('Smart Contract Audit Report', { align: 'center' });
      doc.moveDown(0.5);
      doc.fontSize(12).fillColor('#666').text('DePIN & NodeOps Security Analysis', { align: 'center' });
      doc.moveDown(2);

      // Contract Info
      doc.fontSize(16).fillColor('#1a1a1a').text('Contract Information');
      doc.moveDown(0.5);
      addKeyValue(doc, 'Contract Name', audit.contractName);
      addKeyValue(doc, 'Language', audit.language.toUpperCase());
      addKeyValue(doc, 'Audit Date', new Date(audit.timestamp).toLocaleString());
      addKeyValue(doc, 'Analysis Duration', `${audit.duration.toFixed(2)}s`);
      doc.moveDown(1);

      // Score Section
      doc.fontSize(16).fillColor('#1a1a1a').text('Security Score');
      doc.moveDown(0.5);
      
      const scoreColor = audit.score >= 80 ? '#10b981' : audit.score >= 60 ? '#f59e0b' : '#ef4444';
      doc.fontSize(36).fillColor(scoreColor).text(`${audit.score}/100`, { align: 'center' });
      doc.moveDown(0.5);
      doc.fontSize(12).fillColor('#666').text(audit.summary.recommendation, { align: 'center' });
      doc.moveDown(2);

      // Summary
      doc.fontSize(16).fillColor('#1a1a1a').text('Executive Summary');
      doc.moveDown(0.5);
      addKeyValue(doc, 'Risk Level', audit.summary.riskLevel);
      addKeyValue(doc, 'Total Issues', audit.summary.totalIssues.toString());
      addKeyValue(doc, 'Critical Issues', audit.summary.criticalIssues.toString());
      addKeyValue(doc, 'High Issues', audit.summary.highIssues.toString());
      addKeyValue(doc, 'Medium Issues', audit.summary.mediumIssues.toString());
      addKeyValue(doc, 'DePIN Ready', audit.summary.depinReady ? 'Yes' : 'No');
      addKeyValue(doc, 'NodeOps Compatible', audit.summary.nodeOpsCompatible ? 'Yes' : 'No');
      doc.moveDown(2);

      // Vulnerabilities
      if (audit.vulnerabilities && audit.vulnerabilities.length > 0) {
        doc.addPage();
        doc.fontSize(16).fillColor('#1a1a1a').text('Vulnerabilities');
        doc.moveDown(1);

        audit.vulnerabilities.slice(0, 15).forEach((vuln, index) => {
          if (doc.y > 700) doc.addPage();
          
          doc.fontSize(12).fillColor('#1a1a1a').text(`${index + 1}. ${vuln.title}`);
          doc.fontSize(10).fillColor(getSeverityColor(vuln.severity)).text(`Severity: ${vuln.severity.toUpperCase()}`);
          doc.fontSize(10).fillColor('#666').text(vuln.description, { width: 500 });
          doc.fontSize(10).fillColor('#059669').text(`Fix: ${vuln.remediation}`, { width: 500 });
          doc.moveDown(1);
        });
      }

      // DePIN Insights
      if (audit.depinInsights && audit.depinInsights.length > 0) {
        doc.addPage();
        doc.fontSize(16).fillColor('#1a1a1a').text('DePIN Insights');
        doc.moveDown(1);

        audit.depinInsights.forEach((insight, index) => {
          doc.fontSize(11).fillColor('#1a1a1a').text(`• ${insight.category}: ${insight.finding}`);
          doc.moveDown(0.5);
        });
      }

      // NodeOps Recommendations
      if (audit.nodeOpsRecommendations && audit.nodeOpsRecommendations.length > 0) {
        doc.moveDown(2);
        doc.fontSize(16).fillColor('#1a1a1a').text('NodeOps Recommendations');
        doc.moveDown(1);

        audit.nodeOpsRecommendations.forEach((rec, index) => {
          doc.fontSize(11).fillColor('#1a1a1a').text(`• ${rec.title}`);
          doc.fontSize(10).fillColor('#666').text(`  ${rec.description}`);
          doc.moveDown(0.5);
        });
      }

      // Footer
      doc.fontSize(8).fillColor('#999').text(
        'Generated by DePIN Contract Auditor | For security purposes only',
        50,
        doc.page.height - 50,
        { align: 'center' }
      );

      doc.end();
    } catch (error) {
      reject(error);
    }
  });
}

function addKeyValue(doc, key, value) {
  doc.fontSize(11).fillColor('#1a1a1a').text(`${key}: `, { continued: true })
     .fillColor('#666').text(value);
  doc.moveDown(0.3);
}

function getSeverityColor(severity) {
  const colors = {
    critical: '#dc2626',
    high: '#ea580c',
    medium: '#f59e0b',
    low: '#84cc16',
    info: '#06b6d4'
  };
  return colors[severity] || '#666';
}
